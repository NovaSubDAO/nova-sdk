{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Nova SDKs","text":"<p>Nova is a new Maker actor whose goal is to explore new ( \u201cnova\u201d ) market segments for the Maker Ecosystem.</p> <p>Our initial target is on crypto newcomers / beginners across Emerging Markets, ie. those users who are NOT DeFi native and bring them easy access to Maker offerings such as our savings rate and upcoming token farms.</p> <p>We believe this is best achieved through a B2B model and we provide SDKs to enable an easy and rapid integration for our distribution partners.</p> <p>We currently support Go SDK. Please find its technical documentation in the left bar.</p>"},{"location":"bridging_sdai/","title":"Bridging the gap between Mainnet and Foreign Domains","text":"<p>Nova bridges sDAI (or uses already bridged sDAI) by harnessing the canonical domain bridges, for example:</p> <ul> <li>The Optimism Superchain Bridge for Optimism and BASE</li> <li>The Arbitrum Bridge for Arbitrum</li> <li>The Polygon PoS bridge for Polygon Mainnet</li> </ul> <p>This ensures native compatibility with target domains and reduces trust between the end user and Nova. The bridged sDAI token is entrusted to the chain's own bridging mechanism.</p> <p>Warning</p> <p>Integrators and users should keep in mind that funds on a domain other than Ethereum Mainnet are at the mercy of its bridge, no matter which asset they hold.</p>"},{"location":"bridging_sdai/#caveats","title":"Caveats","text":"<p>Bridging in this fashion removes the direct connection between sDAI on foreign domains, and the canonical sDAI contract on Mainnet. This is due to the fact that redemptions for sDAI on the foreign side cannot communicate through the bridge at this point in time. We solve this by introducing market mechanisms that help keep foreign sDAI at a fair price compared to the canonical price provided by the Mainnet sDAI contract.</p>"},{"location":"bridging_sdai/#getting-sdais-price-right","title":"Getting sDAI's price right","text":"<p>We rely exclusively on AMM pools to be able to offer sDAI on foreign domains. This requires us to be peroactive in keeping a healthy, liquid market for sDAI and whichever other stablecoins we support.</p> <p>Section about how we ensure deep liquidity for different sDAI-stable pairs on foreign domains</p>"},{"location":"bridging_sdai/#supported-venues","title":"Supported Venues","text":"<p>The initial Nova Contract deployment only supports the Velodrome USDC/sDAI Concentrated Liquidity Pool on Optimism. As we leave the PoC phase, we will expand to both other domains and other liquidity pool venues, for better coverage of the domains where users live.</p>"},{"location":"sdk_documentation/","title":"SDK Documentation","text":"<p>The NovaVault SDK for Go enables developers to interact with the NovaVault contract for managing stablecoins. The SDK simplifies tasks like depositing, withdrawing, and querying financial data within a liquidity pool.</p>"},{"location":"sdk_documentation/#overview-of-functions","title":"Overview of Functions","text":"<p>This SDK implements the follow interface:</p> <pre><code>type SdkInterface interface {\n    GetPrice(constants.Stablecoin) (*big.Int, error)\n    GetPosition(constants.Stablecoin, common.Address) (*big.Int, error)\n    GetSlippage(constants.Stablecoin, *big.Int) (float64, float64, float64, error)\n\n    GetConfig() (*config.Config)\n    GetSDaiPrice() (*big.Int, error)\n    GetSDaiTotalValue() (*big.Int, error)\n    GetSupportedStablecoins() ([]constants.Stablecoin, error)\n\n    CreateDepositTransaction(constants.Stablecoin, common.Address, *big.Int, *big.Int) (string, error)\n    CreateWithdrawTransaction(constants.Stablecoin, common.Address, *big.Int, *big.Int) (string, error)\n}\n</code></pre>"},{"location":"sdk_documentation/#function-details","title":"Function Details","text":""},{"location":"sdk_documentation/#getprice","title":"GetPrice","text":"<p>Retrieves the current price of a specified stablecoin in the liquidity pool stable/sDAI.</p>"},{"location":"sdk_documentation/#parameters","title":"Parameters","text":"<ul> <li><code>stablecoin (constants.Stablecoin)</code>: The type of stablecoin for which to retrieve the price.</li> </ul>"},{"location":"sdk_documentation/#returns","title":"Returns","text":"<ul> <li><code>price (*big.Int)</code>: The current price of the specified stablecoin.</li> <li><code>error</code>: Error if the price retrieval fails.</li> </ul>"},{"location":"sdk_documentation/#example","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n)\n\nfunc main() {\n    price, err := novaSdk.GetPrice(\"USDC\")\n    if err != nil {\n        fmt.Println(\"Error retrieving price:\", err)\n    } else {\n        fmt.Println(\"Price:\", price)\n    }\n}\n</code></pre>"},{"location":"sdk_documentation/#getposition","title":"GetPosition","text":"<p>Retrieves the value of the position held by a specified user address in the given stablecoin.</p>"},{"location":"sdk_documentation/#parameters_1","title":"Parameters","text":"<ul> <li><code>stablecoin</code> (<code>constants.Stablecoin</code>): The type of stablecoin for which to retrieve the position.</li> <li><code>address</code> (<code>common.Address</code>): The user's wallet address.</li> </ul>"},{"location":"sdk_documentation/#returns_1","title":"Returns","text":"<ul> <li><code>position</code> (<code>*big.Int</code>): The current value of the user's position.</li> <li><code>error</code>: Error if the position retrieval fails.</li> </ul>"},{"location":"sdk_documentation/#example_1","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/ethereum/go-ethereum/common\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n)\n\nfunc main() {\n    address := common.HexToAddress(\"0x123...\")\n    position, err := novaSdk.GetPosition(\"USDC\", address)\n    if err != nil {\n        fmt.Println(\"Error retrieving position:\", err)\n    } else {\n        fmt.Println(\"Position value:\", position)\n    }\n}\n</code></pre>"},{"location":"sdk_documentation/#getslippage","title":"GetSlippage","text":"<p>Calculates the current slippage percentage for a swap transaction based on the specified amount to swap.</p>"},{"location":"sdk_documentation/#parameters_2","title":"Parameters","text":"<ul> <li><code>stablecoin</code> (<code>constants.Stablecoin</code>): The type of stablecoin involved in the swap.</li> <li><code>amount</code> (<code>*big.Int</code>): The amount of stablecoin to be swapped. This amount is raw and should use the correct number of decimals.</li> </ul>"},{"location":"sdk_documentation/#returns_2","title":"Returns","text":"<ul> <li><code>slippage</code> (<code>float64</code>): The calculated slippage percentage.</li> <li><code>expectedPrice</code> (<code>float64</code>): The expected price when depositing 1 stablecoin (i.e. an amount of 10 ** decimals).</li> <li><code>executedPrice</code> (<code>float64</code>): The executed price when deposoting amount.</li> <li><code>error</code>: Error if the slippage calculation fails.</li> </ul>"},{"location":"sdk_documentation/#example_2","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n)\n\nfunc main() {\n    rpcEndpoint := \"https://your-rpc-endpoint\"\n    chainId := int64(123)\n    novaSdk, err := sdk.NewNovaSDK(rpcEndpoint, chainId)\n\n    amountToSwap := big.NewInt(1000) // example amount to swap\n    slippage, err := novaSdk.GetSlippage(\"USDC\", amountToSwap)\n    if err != nil {\n        fmt.Println(\"Error calculating slippage:\", err)\n    } else {\n        fmt.Printf(\"Slippage percentage: %.2f%%\\n\", slippage)\n    }\n}\n</code></pre>"},{"location":"sdk_documentation/#getconfig","title":"GetConfig","text":"<p>Retrieves the config of the instance.</p>"},{"location":"sdk_documentation/#returns_3","title":"Returns","text":"<ul> <li><code>config</code> (*config.Config): SDK config, containing vault address, vault decimals, sDai address, rpc endpoint and chain id.</li> </ul>"},{"location":"sdk_documentation/#example_3","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n)\n\nfunc main() {\n    rpcEndpoint := \"https://your-rpc-endpoint\"\n    chainId := int64(123)\n    novaSdk, err := sdk.NewNovaSDK(rpcEndpoint, chainId)\n\n    cfg := novaSdk.GetConfig()\n\n    fmt.Println(\"Vault address:\", cfg.VaultAddress)\n    fmt.Println(\"Vault decimals:\", cfg.VaultDecimals)\n    fmt.Println(\"sDai address:\", cfg.SDai)\n}\n</code></pre>"},{"location":"sdk_documentation/#getsdaiprice","title":"GetSDaiPrice","text":"<p>Retrieves the current price of sDAI on Ethereum.</p>"},{"location":"sdk_documentation/#returns_4","title":"Returns","text":"<ul> <li><code>price</code> (*big.Int): The current price of sDAI.</li> <li><code>error</code>: Error if the price retrieval fails.</li> </ul>"},{"location":"sdk_documentation/#example_4","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n)\n\nfunc main() {\n    rpcEndpoint := \"https://your-rpc-endpoint\"\n    chainId := int64(123)\n    novaSdk, err := sdk.NewNovaSDK(rpcEndpoint, chainId)\n\n    price, err := novaSdk.GetSDaiPrice()\n    if err != nil {\n        fmt.Println(\"Error retrieving sDAI price:\", err)\n    } else {\n        fmt.Println(\"sDAI Price:\", price)\n    }\n}\n</code></pre>"},{"location":"sdk_documentation/#getsdaitotalvalue","title":"GetSDaiTotalValue","text":"<p>Retrieves the total value of sDAI in the domain, using the Ethereum price of sDAI.</p>"},{"location":"sdk_documentation/#returns_5","title":"Returns","text":"<ul> <li><code>totalValue</code> (*big.Int): The total value of sDAI.</li> <li><code>error</code>: Error if the value retrieval fails.</li> </ul>"},{"location":"sdk_documentation/#example_5","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n)\n\nfunc main() {\n    rpcEndpoint := \"https://your-rpc-endpoint\"\n    chainId := int64(123)\n    novaSdk, err := sdk.NewNovaSDK(rpcEndpoint, chainId)\n\n    totalValue, err := novaSdk.GetSDaiTotalValue()\n    if err != nil {\n        fmt.Println(\"Error retrieving total value of sDAI:\", err)\n    } else {\n        fmt.Println(\"Total value of sDAI:\", totalValue)\n    }\n}\n</code></pre>"},{"location":"sdk_documentation/#getsupportedstablecoins","title":"GetSupportedStablecoins","text":"<p>Retrieves the list of supported stablecoins by Nova for the chain id set in configuration.</p>"},{"location":"sdk_documentation/#returns_6","title":"Returns","text":"<ul> <li><code>stables</code> ([]constants.Stablecoin): The list of supported stablecoins for this chain id.</li> <li><code>error</code>: Error if the list retrieval fails.</li> </ul>"},{"location":"sdk_documentation/#example_6","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n)\n\nfunc main() {\n    rpcEndpoint := \"https://your-rpc-endpoint\"\n    chainId := int64(123)\n    novaSdk, err := sdk.NewNovaSDK(rpcEndpoint, chainId)\n\n    stables, err := novaSdk.GetSupportedStablecoins()\n    if err != nil {\n        fmt.Println(\"Error retrieving list of stablecoinsI:\", err)\n    } else {\n        fmt.Println(\"List of supported stablecoins:\", stables)\n    }\n}\n</code></pre>"},{"location":"sdk_documentation/#createdeposittransaction","title":"CreateDepositTransaction","text":"<p>Creates a deposit transaction for a specified stablecoin to be signed by the user. This function requires the stablecoin type, the user wallet address, the amount to deposit, and an optional referral code.</p>"},{"location":"sdk_documentation/#parameters_3","title":"Parameters","text":"<ul> <li><code>stablecoin</code> (<code>constants.Stablecoin</code>): The type of stablecoin to deposit.</li> <li><code>address</code> (<code>common.Address</code>): The user's wallet address.</li> <li><code>amount</code> (<code>*big.Int</code>): The amount of stablecoin to deposit.</li> <li><code>referral</code> (<code>*big.Int</code>, optional): A referral code for tracking or rewards, if applicable.</li> </ul>"},{"location":"sdk_documentation/#returns_7","title":"Returns","text":"<ul> <li><code>transactionObject</code> (string): Deposit transaction object, to be signed by the user.</li> <li><code>error</code>: Error if the transaction creation fails.</li> </ul>"},{"location":"sdk_documentation/#example_7","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"github.com/ethereum/go-ethereum/common\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/constants\"\n)\n\nfunc main() {\n    rpcEndpoint := \"https://your-rpc-endpoint\"\n    chainId := int64(123)\n    novaSdk, err := sdk.NewNovaSDK(rpcEndpoint, chainId)\n\n    stablecoin := constants.USDC\n    userAddress := common.HexToAddress(\"0x123...\")\n    depositAmount := big.NewInt(1000)\n    referralCode := big.NewInt(101)\n\n    transactionObject, err := novaSdk.CreateDepositTransaction(stablecoin, userAddress, depositAmount, referralCode)\n    if err != nil {\n        fmt.Println(\"Error creating deposit transaction:\", err)\n    } else {\n        fmt.Println(\"Deposit transaction to be signed:\", transactionObject)\n    }\n}\n</code></pre>"},{"location":"sdk_documentation/#createwithdrawtransaction","title":"CreateWithdrawTransaction","text":"<p>Creates a withdraw transaction for a specified stablecoin to be signed by the user. This function requires the stablecoin type, the user wallet address, the amount to withdraw, and an optional referral code.</p>"},{"location":"sdk_documentation/#parameters_4","title":"Parameters","text":"<ul> <li><code>stablecoin</code> (<code>constants.Stablecoin</code>): The type of stablecoin to withdraw.</li> <li><code>address</code> (<code>common.Address</code>): The user's wallet address.</li> <li><code>amount</code> (<code>*big.Int</code>): The amount of stablecoin to withdraw.</li> <li><code>referral</code> (<code>*big.Int</code>, optional): A referral code for tracking or rewards, if applicable.</li> </ul>"},{"location":"sdk_documentation/#returns_8","title":"Returns","text":"<ul> <li><code>transactionObject</code> (string): Withdraw transaction object, to be signed by the user.</li> <li><code>error</code>: Error if the transaction creation fails.</li> </ul>"},{"location":"sdk_documentation/#example_8","title":"Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n    \"github.com/ethereum/go-ethereum/common\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/sdk\"\n    \"github.com/NovaSubDAO/nova-sdk/go/pkg/constants\"\n)\n\nfunc main() {\n    rpcEndpoint := \"https://your-rpc-endpoint\"\n    chainId := int64(123)\n    novaSdk, err := sdk.NewNovaSDK(rpcEndpoint, chainId)\n\n    stablecoin := constants.USDC\n    userAddress := common.HexToAddress(\"0x123...\")\n    withdrawAmount := big.NewInt(500)\n    referralCode := big.NewInt(102)\n\n    transactionObject, err := novaSdk.CreateWithdrawTransaction(stablecoin, userAddress, withdrawAmount, referralCode)\n    if err != nil {\n        fmt.Println(\"Error creating withdraw transaction:\", err)\n    } else {\n        fmt.Println(\"Withdraw transaction to be signed:\", transactionObject)\n    }\n}\n</code></pre>"},{"location":"the_nova_contract/","title":"sDAI for the regular user","text":"<p>On a relatively large number of countries, DAI isn't what users are used to. They usually place their savings in other stablecoins, such as USDT (Tether) and USDC (Circle) - both of which don't pay them any APR for holding them. If they want to get any rate for those stablecoins, their only choice is to find an existing strategy that might pay some APR for their stablecoins.</p> <p>These strategies include usage of lending markets, liquidity pools and other technically complex solutions.</p>"},{"location":"the_nova_contract/#the-nova-contract","title":"The Nova Contract","text":"<p>The Nova Contract is an adapter for sDAI, which lets users harness the yield paid by Maker to DAI holders - all while still using their stablecoin of choice. This contract exchanges their stablecoin for sDAI in both directions, and allows users and integrators to more easily view their stablecoin balance and the rate users have been paid so far. The system looks the following way</p> <pre><code>sequenceDiagram\n    actor U as User\n    participant N as Nova Contract (sUSDC)\n    participant AMM\n    U -&gt;&gt; N: deposit USDC\n    N -&gt;&gt; AMM: swap USDC for sDAI\n    N -&gt;&gt; U: mint sUSDC shares\n    note over N,AMM: In this case, the pool liquidity\n    note over N,AMM: was sufficient for the swap.\n\n    participant Arbitrator\n    participant Bridge\n    Arbitrator(Mainnet) -&gt;&gt; Bridge: initiate sDAI bridging\n    Bridge -&gt;&gt; Arbitrator: send sDAI\n    Arbitrator -&gt;&gt; AMM: refill sDAI\n</code></pre> <p>The minted sUSDC is thus a thin wrapper over the bridged sDAI, since it can always be exchanged 1:1 for sDAI, and the latter can be exchanged for USDC in the AMM. As long as the market is liquid, users can expect to be able to withdraw their sUSDC shares for USDC. See Bridging sDAI for more details on that.</p>"},{"location":"what_is_sdai/","title":"What is sDAI?","text":"<p>sDAI is MakerDAO's yield bearing token, which acts as an index of Maker's return on its investment portfolio. The interest rate paid is set by the Maker Governance depending on market conditions. It is an evolution of Maker's DAI Savings Rate, which is functionally similar but does not have a token representation.</p>"},{"location":"what_is_sdai/#understanding-the-dai-savings-rate-dsr","title":"Understanding the DAI Savings Rate (DSR)","text":"<p>MakerDAO offers the Savings Rate as one of its monetary policy tools, and uses it to influence the supply and demand for DAI by making it either more attractive to hold or to exchange for other stablecoins. The yield paid by the Savings Rate is directly informed by the return on Maker's loans, be them CDPs<sup>1</sup>, loans to other entities (i.e. Spark) or, most recently, Ethena.</p> <pre><code>graph LR\n    M{MakerDAO} --&gt; |pays yield to| D{DSR}\n    D --&gt; |accumulates yield for| U(User)\n    U --&gt; |deposits dai| D\n</code></pre> <p>It is worth noting that the DSR accepts deposits and withdrawals at no cost to the end user (apart from gas fees). For more in-depth technical information on the DSR, check out the official DSR docs.</p> <p>sDAI offers a much easier way to interact and integrate with this system.</p>"},{"location":"what_is_sdai/#how-it-works","title":"How it works","text":"<p>sDAI is a wrapper contract built on top of the existing DAI Savings Rate which represents user balances in the form of an ERC4626 vault. This enables use cases that weren't possible before, including but not limited to:</p> <ul> <li>Better support for the DAI Savings Rate on wallets</li> <li>Easy transfers of staked balances</li> <li>Bridging the yield over to L2 and alt-L1 networks</li> </ul> <p>It effectively sits between end users and integrators to provide a better interface for the DAI Savings Rate, minimizing user friction and enabling usage of this yield on DeFi.</p> <pre><code>graph LR\n    M{MakerDAO} --&gt; D{DSR}\n    S{sDAI} --&gt; |makes deposit| D\n    D --&gt;  |accumulates yield for| S\n    U(User) --&gt; |deposits into| S\n</code></pre> <p>sDAI has been successfully integrated as a core piece of other protocol's infrastructure, such as Blast, where it is used as the basis for all stablecoins held in the network.</p> <p>Note</p> <p>The sDAI vault contract on Ethereum Mainnet is located at 0x83F20F44975D03b1b09e64809B757c47f942BEeA.</p>"},{"location":"what_is_sdai/#sdais-value-proposition-on-other-domains","title":"sDAI's value proposition on other domains","text":"<p>Being a tokenized vault, it is possible to offer users this yield on other, low transaction fee domains. This enables users to harness this yield offering at a lower cost of entry, and encourages its use as a high-yield savings account, accessible by people for whom Ethereum transaction fees are unfeasibly high.</p> <p>Users or integrators may acquire sDAI on Mainnet by minting it from the contract directly, or on other domains by acquiring it from an Automated Market Maker such as Uniswap. We recommend usage of our SDK for this reason, since it is directly pointed to the best-performing AMMs for this purpose.</p> <ol> <li> <p>Collateralized Debt Positions\u00a0\u21a9</p> </li> </ol>"}]}